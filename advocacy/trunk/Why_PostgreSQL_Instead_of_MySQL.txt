//Why PostgreSQL Instead of MySQL: Comparing Reliability and Speed in 2007
Pourquoi PostgreSQL plutôt que MySQL : Comparaison de la fiablité et rapidité en 2007

Introduction

//For years, the common industry perception has been that MySQL is faster and easier to use than PostgreSQL. 
//PostgreSQL is perceived as more powerful, more focused on data integrity, and stricter at complying with 
//SQL specifications, but correspondingly slower and more complicated to use.
Pendant des années, la perception du marché était que MySQL était plus rapide et facile à utiliser que PostgreSQL.
PostgreSQL est perçu comme étant plus puissant, focalisé sur l'intégrité des données, et plus respecteux des normes
SQL, mais également plus lent et plus compliqué à utiliser.

//Like many perceptions formed in the past, these things aren't as true with the current generation of releases as 
//they used to be. Both systems have evolved with landmark releases that make comparing the two a lot more complicated.
Puisque beaucoup de ces perceptions sont apparues dans le passé, ces choses ne sont plus aussi vraies avec les versions actuelles que celà n'a été. Les deux systèmes ont évolué avec des versions notables qui rendent leur comparaison beaucoup plus compliquée.

//    * MySQL 5.0 (October 2005) finally added a "strict mode" to narrow the gap in terms of data integrity and spec 
// compliance. It also added support for stored procedures, views, triggers, and cursors, all considered essential 
// features for some classes of database deployments.
	* MySQL 5.0 (Octobre 2005) a finalement ajouté un "strict mode" pour réduire l'écart en terme d'intégrité des 
	données et de conformité aux specs. Le support des procédures stockées, vues, déclencheurs et curseurs, tous 
	considérés comme des fonctionnalités essentielles dans plusieurs cas de déploiement de base de données, a 
	aussi été ajouté.
//    * PostgreSQL 8.1 (November 2005) featured major performance improvements, particularly in scalability. Focusing 
// on improving performance has been central to all the 8.X releases up to the current 8.2.
	* PostgreSQL 8.1 (Novembre 2005) apporte d'importantes améliorations de performance, particulièrement en terme 
	d'évolutivité. L'attention a principalement été portée sur l'amélioration des performances pour toutes les 
	versions 8.X et jusqu'à l'actuelle 8.2.

// As innovation on these databases has progressed, each development community has actively made changes to address 
// their respective sets of perceived disadvantages. The result that it has gotten more difficult to objectively 
// determine which database is likely to be better suited for a given application. This document aims to clarify what 
// situations PostgreSQL would be more appropriate for than MySQL, attempting to fairly compare the current production
// versions of each and discuss their strengths and weaknesses. The main areas covered here are the fundamental data 
// integrity and speed issues of the core database software. Since it's often the case that you can trade-off 
// performance against reliability, both these topics need to be considered together in order to get an accurate view 
// of the landscape.
Alors que l'innovation sur ces deux bases a progressé, chacune des communautés de développement a travaillé
activement à réduire leur liste de désavantages perçus. Le résultat est qu'il est devenu plus difficile de déterminer 
objectivement quelle base de données est susceptible de convenir à une application donnée. Ce document vise à clarifier 
dans quelles situations PostgreSQL est plus approprié que MySQL, en essayant de comparer équitablement les versions de
production courantes de chacune et d'en discuter les forces et faiblesses. Les domaines principalement étudiés ici 
concernent les questions fondamentales de l'intégrité des données et la rapidité du noyau logiciel de la base de
données. Puisqu'il est souvent question de faire un choix entre la performance ou la fiabilité, ces deux sujets
doivent être considérés conjointement afin d'avoir une vision précise de l'ensemble.

// The position of this paper is that when the two are compared using the high level of data integrity demanded by a 
// serious transactional database application, the current generation PostgreSQL performs similarly or better than 
// MySQL (particularly under heavy user loads and with complex queries), while retaining its lead in the areas of SQL 
// standards compliance and a rich feature set. It is also hoped that by exploring the differences between the two 
// systems, you might come to appreciate how the fundamental approach of the PostgreSQL design team pervasively 
// prioritizes reliable and predictable behavior. Similar portions of the MySQL implementation have some seams 
// resulting from how features like transactional support and strict mode were added onto the software well into its 
// design lifecycle rather than being integral from the start.
// Compared Versions, Feature Sets, and Focus
La position de ce document est que lorsque nous comparons les deux pour une application sérieuse exigeant un haut 
degré d'intégrité des données dans une base transactionnelle, la génération actuelle de PostgreSQL s'exécutera aussi
bien ou mieux que MySQL (particulièrement avec une charge importante d'utilisateur et de requêtes complexes), tout 
en conservant son avance dans sa conformité aux standards SQL et sa richesse de fonctionnalité. Il est aussi espéré 
qu'en explorant les différences entre les deux systèmes, vous arriviez à apprécier l'approche fondamentale de l'équipe
de conception de PostgreSQL qui s'évertue à prioriser un comportement fiable et prévisible. Les portions similaires de
l'implémentation de MySQL ont quelques rapiècements résultant de la façon dont les fonctionnalités comme le support
des transactions et le mode stricte ont été ajoutés au logiciel au court de son cycle de vie plutôt qu'intégralement
dès le début.

Comparaison des Versions, Ensemble de Fonctionnalités et Détails

// The current production-ready versions as this is written in August of 2007 are PostgreSQL 8.2 and MySQL 5.0, and 
// those are what's being compared here. Since both PostgreSQL 8.1 and 8.2 are currently supported versions with good 
// performance, some comments here may refer to them collectively. 8.2 is moderately faster (perhaps as much as 30% so
// on some workloads), but deploying 8.1 is still a completely viable option right now, particularly because more 
// operating systems vendors bundle and support it than the relatively new 8.2.
Les versions actuelles prêtes à la production en ce mois d'août 2007 sont PostgreSQL 8.2 et MySQL 5.0, et feront donc 
ici l'objet de notre comparaison. Comme PostgreSQL 8.1 et 8.2 sont toutes deux actuellement des versions supportées 
avec de bonnes performances, certains des commentaires suivant pourront y faire références indistinctement. 8.2 est 
sensiblement plus rapide (peut-être pas moins de 30% sur certaines tâches), mais déployer 8.1 reste une option tout à 
fait viable pour le moment, particulièrement dû au fait que les vendeurs de système d'exploitation la distribuent 
et la prennent en charge plus souvent que la 8.2 encore relativement récente.

// Both systems have newer versions in testing (PostgreSQL 8.3 and MySQL 5.1) at this time that offer incremental 
// improvements to some areas this document addresses, but there are no fundamental differences so large in either new
// version that it's believed the general guidelines here would be invalidated. The official release of the MySQL 
// Falcon engine in the future is one likely disruptive point on the horizon. The Asynchronous Commit feature in 
// PostgreSQL 8.3 is another upcoming event that will shift the reliability/performance trade-off options available 
// significantly.
Les deux systèmes ont de nouvelles versions en phase de tests (PostgreSQL 8.3 et MySQL 5.1) en ce moment qui offrent de
nouvelles améliorations dans plusieurs domaines traités ici, mais aucune des deux n'apporte de différences
fondamentales si importantes qu'elles laisseraient penser que les principales orientations de ce document en seraient
infirmées. La sortie officielle du moteur Falcon de MySQL est probablement l'un des futur points perturbateur à 
l'horizon. La fonctionnalité d'Execution Asynchrone dans PostgreSQL 8.3 est un autre évènement prochain qui étendra
significativement les différentes options disponibles pour affiner la configuration entre fiabilité et performance.

// What is specifically not addressed here are the feature sets of the two products in areas outside of these
// fundamentals. Because the scale of the changes in PostgreSQL 8.1 and MySQL 5.0, many of the documents covering this 
// topic are too out of date to recommend. Some pages that may be helpful include:
Ce qui ne sera pas spécifiquement abordé ici seront les fonctionnalités des deux produits dans des domaines extérieurs 
à ces fondamentaux. A cause de l'importance des changements dans PostgreSQL 8.1 and MySQL 5.0, beaucoup des documents
concernant ce sujet sont trop vieux pour être recommandés. Incluant certaines pages qui auraient pû être utiles :

//    * Open Source Database Feature Comparison Matrix
	* Matrice de comparaison des fonctionnalités des bases de données Open Source
//    * MySQL vs. PostgreSQL
	* MySQL contre PostgreSQL
//    * MySQL Development Roadmap
	* Prévision de développement de MySQL
//    * PostgreSQL Feature Matrix
	* Matrice des fonctionnalités de PostgreSQL

// While feature checklists are useful, some system behaviors require a fairly deep understanding of the respective 
// systems to appreciate. For instance, the internals of how PostgreSQL compresses TOAST data are invisible to the 
// user, but can result in a startling improvement in system performance with certain types of data.
Alors que les listes des fonctionnalités sont utiles, certains comportements internes nécessitent une compréhension
profonde des systèmes respectifs pour bien les saisir. Par exemple, les mécanismes internes concernant la façon
dont PostgreSQL compresse les données TOAST sont invisibles aux utilisateurs, mais peuvent mener à une amélioration 
drastique des performances systèmes sur certains types de donnée.

// Another area outside of the scope of this document is that more applications support MySQL as the database of 
// choice than PostgreSQL, and certainly that is an important factor for deciding which of these databases is better 
// suited for a particular situation. Work on adding PostgreSQL support to some popular applications can be tracked at
// Software Ports. One thing you should evaluate when considering how applications use MySQL is that if they were
// initially targeted at versions before 5.0, they may not be compatible with newer features like the strict mode
// introduced in that version. If that's the case, such applications may be limited to the capabilities of the older
// version they were written against, and it may require a sort of porting effort to take advantage of the modern MySQL
// features.
Un autre sujet qui sort du cadre de ce document est qu'un nombre plus important d'applications choisissent MySQL comme
base de données plutôt que PostgreSQL, et ceci est certainement un facteur d'influence important sur le choix de la
base la plus adaptée à une situation particulière. Le travail pour ajouter un support PostgreSQL à plusieurs 
applications populaires peut-être mené en adaptant les logiciels. Une chose que vous devez considérer lorsque vous
étudiez comment les applications utilisent MySQL est si elles sont initialement destinées aux versions antérieures à
5.0, elles pourraient alors ne plus être compatibles avec les nouvelles fonctionnalités comme le mode strict ajouté
dans cette version. Si cela est le cas, de telles applications pourraient être limitées aux capacités des plus vieilles
versions pour lesquelles elles ont été écrites et pourraient demander un effort d'adaptation pour profiter des
fonctionnalités modernes de MySQL.

// Reliability
Fiabilité

// Data Integrity
Intégrité des Données

// Before version 5.0, MySQL well deserved its reputation for allowing inconsistent data to be inserted into the
// database. Guaranteeing Data Integrity with MySQL 5.0 explains the issues with older MySQL versions, and how they may
// be addressed using the strict SQL Mode available in the current version. Of course, any MySQL client is allowed to
// change its own SQL Mode to override this, with the result that these validation constraints are still not 
// necessarily enforced by the server.
Avant la version 5.0, MySQL méritait clairement sa réputation à propos d'insertion de données inconsistantes dans la
base de données. "Guaranteeing Data Integrity with MySQL 5.0" explique les problèmes avec ces plus vieilles versions de
MySQL, et comment ils pourraient être évités en utilisant le "Mode SQL" strict disponnible dans la version actuelle.
Bien entendu, tout client MySQL a la possibilité de changer son mode SQL et contourner ainsi ce comportement, avec
comme conséquences que ces validations de contraintes ne soient plus forcément assurées coté serveur.

// PostgreSQL has always been strict about making sure data is valid before allowing it into the database, and there is
// no way for a client to bypass those checks.
PostgreSQL a toujours été strict sur la validation des données avant de les insérer dans la base de données, et il 
n'existe aucune alternative au client pour contourner ces vérifications.

// Transactions and the Database Engine Core
Les Transactions et le Moteur Interne de la Base de Donnée

// The database core that gave MySQL its original reputation for speed is MyISAM. This engine has excellent read
// performance and its parser is very efficient for straightforward queries, which combine to make it very fast in
// read-intensive applications like web applications involving simple SELECTs. However, it is commonly known that
// MyISAM is more vulnerable to data corruption than most serious database applications would tolerate, and after a
// crash there may be a substantial delay while it rebuilds its indexes before the server can restart. Furthermore,
// it does not support foreign keys or transactions that would allow the database to have ACID properties. MyISAM
// also has issues dealing with concurrent reads and updates, since it only provides table level locking.
MyISAM est le composant interne de MySQL à l'origine de sa réputation de rapidité. Ce moteur a d'excellentes
performances en lecture et son analyseur est vraiment très efficace pour les requêtes simples, ce qui le rendent
trés rapide pour les applications en lecture intensive comme les applications web qui emploient de simple SELECTs.
Cependant, il est communément connu que MyISAM est plus vulnérable aux corruptions de données que la plupart des
bases de données sérieuses ne sauraient tolérer, et en cas d'incident, il peut s'écouler un temps non négligeable
durant lequel il reconstruit ses indexes avant que le serveur ne puisse redémarrer. En outre, il ne supporte pas les
clés étrangères ou les transactions qui auraient permis à la base d'avoir des propriétés ACID. MyISAM a aussi un
problème avec les accès concurrents en lecture et mise à jour car ne supporte que les verrous de niveau table.

// The integration of the InnoDB Storage Engine to MySQL greatly improved over MyISAM in terms of data integrity,
// adding a more robust log replaying mechanism for crash recovery and enabling ACID compliant transactions. However,
// this new approach comes with much more overhead, and InnoDB tables are not as fast as MyISAM ones for pure read
// loads. In addition, the internal MySQL metadata tables are still stored using MyISAM, which means they remain
// vulnerable to the traditional corruption issues associated with that storage engine. This issue is worked around
// using some complicated locking methods that have the potential to make a table alteration block for some time.
L'intégration du moteur de stockage InnoDB à MySQL a grandement surpassé MyISAM en terme d'intégrité des données,
ajoutant un mécanisme de ré-exécution des journaux plus robuste pour la restauration après incident et supportant des
transactions ACID. Cependant, cette nouvelle approche apporte aussi beaucoup plus de charge, et les tables InnoDB ne
sont pas aussi rapides que les MyISAM pour les accès en lecture pure. De plus, les tables des métadonnées internes à
MySQL sont toujours stockées en MyISAM, ce qui signifie qu'elles restent vulnérables aux traditionnels problèmes de
corruption associés à ce moteur de stockage. Ce problème peut-être contourné en utilisant plusieurs méthodes de
verrous compliqués qui peuvent potentiellement bloquer l'édition d'une table pendant un certain temps.

// PostgreSQL has always focused on data integrity at the transaction level, keeping locking issues to a minimum, and
// barring hardware failure or grossly improper configuration it is difficult to corrupt a database.
PostgreSQL a toujours porté attention à l'intégrité des données au niveau transactionnel, se gardant ainsi des
problèmes de verrou au minimum, et empêchant une erreur matériel ou une configuration extrêmement mauvaise de corrompre
la base de données.

// It is worth observing that the database engine is part of the core of PostgreSQL, whereas InnoDB is a
// dual-licensed product presently licensed from Oracle Corporation. It is uncertain how Oracle may alter InnoDB in the
// future as they act in competition with MySQL AB, whereas PostgreSQL has no such conflict of interests. MySQL AB has
// been working on a new database engine core called Falcon in order to free themselves from this situation, but
// historically developing a database core engine that is both fast and reliable has required many years of work and
// testing before a mature product suitable for production use is available. Initial benchmarks suggest Falcon has
// plenty of rough edges that need to be addressed.
Il est intéressant de souligner que PostgreSQL intègre entièrement son moteur de base de donnée, alors que InnoDB
est un produit sous licence double actuellement détenu par la société Oracle. L'histoire ne dit pas comment Oracle
modifiera InnoDB dans le futur sachant qu'ils sont eux-même en concurrence avec MySQL AB, alors que PostgreSQL n'a
aucun conflit d'intérêts de la sorte. MySQL AB développe un nouveau moteur de base de données interne appelé Falcon
afin de se libérer de cette situation, mais historiquement, développer un de moteur de base rapide et fiable nécessite
de nombreuses d'années de travail et de tests avant d'obtenir un produit mûr convenant à la production. Les premières 
évaluations suggèrent que Falcon a énormément de points d'approximations qui ont besoins d'être corrigés.

// Foreign Keys
Clés Étrangère

// Proper implementation of design techniques like Database Normalization rely on the ability of the database to use
// Foreign keys to map relationships between tables. In MySQL, foreign keys are only supported with InnoDB. One problem 
// with their implementation is that it is limited and will silently ignore some standard syntax. For example, when
// creating a table, even in the upcoming 5.1 release of MySQL "the CHECK clause is parsed but ignored by all storage 
// engines". The basic design philosophy of PostgreSQL is to produce errors or warnings in similar situations where an 
// operation is ambiguous or unsupported.
L'implémentation correcte des techniques de conception comme les formes normales repose sur la capacité de la base de 
données à utiliser les Clés Étrangères pour représenter les relations entre les tables. Avec MySQL, seul InnoDB supporte
les clés étrangères. Un problème avec de leur implémentation est qu'elle est limitée et ignorera silencieusement
plusieurs syntaxes standard. Par exemple, lors de la création d'une table, même avec la prochaine version 5.1 de MySQL
"la clause CHECK est analysée mais ignorée par tous les moteurs de stockages". À l'origine de PostgreSQL, la philosophie
de conception à été de produire des erreurs ou des avertissements dans les situations similaires où une opération est
ambiguë ou non supportée.

Transactional DDL

In PostgreSQL, when you are inside a transaction almost any operation can be undone. There are some irreversible operations (like creating or destroying a database or tablespace), but normal table modifications can be backed out by issuing a ROLLBACK via its Write-Ahead Log design. That supports backing out even large changes to DDL like table creation.

MySQL doesn't support any sort of rollback when using MyISAM. With InnoDB, the server has an implicit commit that occurs even if the normal auto-commit behavior is turned off. This means that any single table alteration or similar change is immediately committed.

Experienced PostgreSQL DBA's know to take advantage of its features here to protect themselves when doing complicated work like schema upgrades. If you put all such changes into a transaction block, you can make sure they all apply atomically or not at all. This drastically lowers the possibility that the database will be corrupted by a typo or other such error in the schema change, which is particularly important when you're modifying multiple related tables where a mistake might destroy the relational key. There is no way to similar way to safely adjust multiple schema sections with MySQL.

See Transactional DDL in PostgreSQL: A Competitive Analysis for detailed examples demonstrating these differences.
Speed
Default configuration
Historically, the initial PostgreSQL configuration was designed to support older flavors of UNIX where allocating large amounts of memory wasn't necessarily possible. The result was that its use of memory for caching results was, by default, very pessimistic. On modern systems that have lots of memory available, this severely hinders untuned PostgreSQL performance.

The defaults have gotten much less pessimistic in recent releases. System configuration is now examined at database initialization time and more memory allocated if it is possible to do so. As a result, the untuned default configurations on recent PostgreSQL versions perform significantly better than older versions. In addition, changes in cache management in versions 8.1 and 8.2 allow even modest amounts of cache to be used more effectively than they used to be.

The primary tunable for both database systems works similarly, by allocating a block of shared memory dedicated to the database. MySQL tunes this with key_buffer_size when using MyISAM, and with innodb_buffer_pool_size when using InnoDB (note that you still need some MyISAM space for system tables even when InnoDB is the main storage engine for regular tables). PostgreSQL sizes its main memory space with shared_buffers.

The MySQL key_buffer_size defaults to using 8MB of memory. Earlier PostgreSQL configurations would also allocate 8MB of memory for the shared_buffers cache if possible. On a server like a current generation Linux system, it's expected the recent PostgreSQL releases would set shared_buffers to at least 24MB by default when the database cluster is created.

It is still worthwhile to go through the configuration files to tune them to match the available memory on a database server, as all these defaults are dramatically undersized compared to the amount of RAM in current systems. For a modern dedicated server, the rule of thumb for both PostgreSQL and MySQL is to size the dedicated memory to at least 1/4 of the total RAM in the machine, perhaps increasing to as much of 1/2 of RAM on the high side of normal. It's not out of the question to push this percentage even higher when using systems with very large amounts of RAM; MySQL InnoDB guidelines suggest even 80% isn't unreasonable. Performance comparisons using the defaults with either database are completely unrealistic of how a real system would be configured. Initial guidelines in this area can be found at 5-Minute Introduction to PostgreSQL Performance, Optimizing the mysqld variables and Optimizing the MySQL Server.
Benchmarks

Benchmarks are very difficult to do well; creating truly comparable benchmarks is a complex art. Many of the older performance benchmarks that have shown MySQL to be much faster than PostgreSQL have suffered from a number of problem areas:

    * Configuration: It's not unheard of to see a a tuned MySQL compared to an untuned PostgreSQL instance. As mentioned above, untuned PostgreSQL used to be particularly pessimistic about what resources it had available. A truly fair comparison would match the amount of memory used by each system.

    * Transaction support: MyISAM benchmarks involve "transactions" that provide none of the ACID guarantees that PostgreSQL offers. This would frequently mean that apples were being compared to oranges.

    * Transaction grouping: Related to the above, PostgreSQL would sometimes be hindered in naive benchmarks that don't properly group transactions the way a real application would. That can add the overhead of not just one transaction, but perhaps hundreds of thousands, to the cost of doing updates.

    * Serial versus concurrent behaviour: A number of the behaviors of MyISAM are tuned for having a single user accessing the database. For example, its use of table locks to control access to tables means that under heavy user loads, it will slow dramatically. PostgreSQL degrades more gracefully with large numbers of simultaneous connections. Beware of naive benchmarks that involve a simple stream of database requests across a single connection.

Sun Microsystems 2007 jAppServer2004 Benchmark Results

Sun Microsystems, a neutral vendor selling hardware that runs many database types, has recently submitted test results on the well regulated SPECjAppServer2004 using both PostgreSQL and MySQL. There are just enough hardware differences between the two systems that it isn't fair to directly compare the two results. But the fact that both scores are close to one another and the configuration is similar does suggest that while there may be performance differences between the two database systems, the magnitude of that difference is not particularly large with this application type.

For comparison sake, an Oracle on HP result offers a similar magnitude of performance on less impressive hardware, suggesting both open-source databases still lag the best of the commercial products in absolute performance efficiency. Some suggest Oracle's lead is even larger if you pick examples to put it in a better light, but be sure to read Benchmark Brou-Ha-Ha for some comments on actual pricing here (and to pick up some comments on a second PostgreSQL result using a smaller server). Note that Josh Berkus is a Sun employee whose role there includes being a member of the PostgreSQL Core Team, and his commentary should be evaluated accordingly.

If you do a fair comparison that includes software licensing costs, the performance per dollar figures for both PostgreSQL and MySQL are both similar to one another and very good relative to the average for the database industry. It would however be untrue to say that these open-source solutions are always a better choice than commercial offerings like Oracle just based on that; certainly the feature sets and absolute performance of each solution need to be considered as well.
Transaction Locking and Scalability

PostgreSQL uses a robust locking model called
MVCC that limits situations where individual clients interfere with each other. A short summary of the main benefit of MVCC would be "readers are never blocked by writers". MVCC is used to implement a pessimistic implementation of the four SQL standard transaction isolation levels: "when you select the level Read Uncommitted you really get Read Committed, and when you select Repeatable Read you really get Serializable, so the actual isolation level may be stricter than what you select." The default transaction isolation level is "read committed".

MySQL's InnoDB implements MVCC using a rollback segment, inspired by Oracle's design; their new Falcon engine works similarly. InnoDB databases supports all four SQL standard transaction isolation levels, with the default being "repeatable read".

When comparing the two models, PostgreSQL enforces client separation where the data operated on is always consistent under all circumstances; as the MVCC documentation states, "the reason that PostgreSQL only provides two isolation levels is that this is the only sensible way to map the standard isolation levels to the multiversion concurrency control architecture." MySQL allows configurations where client code that doesn't commit transactions properly can result in a data view that would be considered inconsistent by PostgreSQL's stricter standards. However, in situations where it's acceptable for data being read to have small inconsistencies, being able to use a less strict locking could be a performance advantage for MySQL.

Even when both systems are configured to one of the strict levels of transaction locking, the differences between the two implementations are subtle enough that which implementation will work better for a particular application is hard to state definitively. Recommended reading to understand this complicated topic is
"Transactional Information Systems: Theory, Algorithms, and the Practice of Concurrency Control" by Weikum & Vossen. Speaking in the terminology used there, PostgreSQL uses multi-version timestamp ordering (MVTO) while InnoDB and Oracle use multi-version read consistency (MVRC). The main difference is that PostgreSQL is with-REDO/no-UNDO because it stores every row version in the main table, while Oracle/InnoDB implements with-REDO/with-UNDO where they reconstruct a block and/or row image from the log to provide read consistency. If you're willing to consider a third architecture, that of IBM's DB2, as a comparison point additional good references on this topic are A not-so-very technical discussion of Multi Version Concurrency Control and Leverage your PostgreSQL V8.1 skills to learn DB2. IBM is clearly not a fan of the MVCC approach.

Partially because the PostgreSQL locking implementation is very mature (it's always active and performance of the associated code is accordingly critical), even in situations where MySQL initially appears faster PostgreSQL can pull ahead and scale to higher throughput when the number of simultaneous users becomes large. A good example of such a situation is demonstrated in the tweakers.net database test.
Counting rows in a table

One operation that PostgreSQL is known to be slow performing is doing a full count of rows in a table, typically using this SQL:

SELECT COUNT(*) FROM table

The reason why this is slow is related to the MVCC implementation in PostgreSQL. The fact that multiple transactions can see different states of the data means that there can be no straightforward way for "COUNT(*)" to summarize data across the whole table; PostgreSQL must walk through all rows, in some sense. This normally results in a sequential scan reading information about every row in the table.

Some DBMSes provide the ability for "COUNT(*)" queries to work via consulting an index. Unfortunately, in PostgreSQL, this strategy does not work, as MVCC visibility information is not stored at the index level. It is necessary to actually examine the rows themselves to determine if they are visible to the transaction or not.

In MySQL, MyISAM tables cache the row count information, making this type of count operation almost instant. That is the reason why there exists so much MySQL code that uses this construct assuming it's a trivial operation. But if you're using InnoDB instead, this is no longer the case. See
COUNT(*) for Innodb Tables and COUNT(*) vs COUNT(col) for notes on the limitations of MySQL in this area. MySQL designs that may be deployed on InnoDB can't assume that a full row count will be fast, and therefore are hampered by similar limitations to those present in PostgreSQL.

It is worth observing that it is only this precise form of aggregate that must be so pessimistic; if augmented with a "WHERE" clause like

// SELECT COUNT(*) FROM table WHERE status = 'something'
SELECT COUNT(*) FROM table WHERE status = 'quelque chose'

//PostgreSQL, MySQL, and most other database implementations will take advantage of available indexes against 
//the restricted field(s) to limit how many records must be counted, which can greatly accelerate such queries. 
//PostgreSQL will still need to read the resulting rows to verify that they exist; other database systems 
//many only need to reference the index in this situation.
PostgreSQL, MySQL, et beaucoup d'autres implémentations de base de données tireront profil de la disponibilités des
indexes pour le champs restreint afin de limiter le nombre d'enregistrement devant être comptés, ce qui accelère
grandement de telles requêtes.

//One popular approach for applications that need a row count but can tolerate it not including transactions that are 
//in the middle of being committed is to use a trigger-based mechanism to count the rows in the table. In PostgreSQL, 
//another alternative when only an approximate count is needed is to use the reltuples field from the pg_class catalog table.
Une approche apprécié pour les applications qui ont besoin de compter les lignes mais ...

//Join Complexity
Jointure complèxe

//PostgreSQL uses cost-based query optimization methods in order to get good performance for many different types of 
//joins. Query costs are assessed based on planner statistics collected when tables are analyzed combined 
//with adjustable planner costs, and advanced features such as the Genetic Query Optimizer allow optimizing 
//even very complicated joins efficiently.
PostgreSQL utilise une méthode économique d'optimisation des requêtes afin d'obtenir de bonne performances pour les 
différents types de jointures. 
Les requêtes coûteuses sont évalués et basé sur des statistiques du planificateur recueillies quand les tables
sont analysées et combiner avec l'ajustements des coûts du planificateur, et les fonctionnalités avancées tel que le
"Genetix Query Optimizer" permettant l'optimisation efficace de jointûres très compliqués.

//MySQL doesn't have this level of sophistication in its planner, and the tunables for Controlling Query Optimizer 
//Performance are crude. Developers instead do things like explicitly provide index hints to make sure joins 
//are executed correctly. To make this task easier, MySQL provides a Query Profiler that is easier to work with than 
//typical EXPLAIN data. Regardless of hinting, subselect optimization is a known weak spot in MySQL. 
//There is also a fairly serious subquery null handling bug in MySQL 5.0 
//(which at this time appears to be still present in 5.1).



//Finding order in execution provides several comparisons of how the two databases handle queries differently. 
//Because of its more robust automatic optimization, PostgreSQL usually does a better job of handling complicated 
//joins than MySQL--but only if the planner is properly configured (setting the effective_cache_size tunable too small 
//is one common mistake) and statistics about the tables are kept up to date (typically via auto-vacuum). 
//The fact that you must give the PostgreSQL optimizer correct information to work with, and can't explicitly control 
//which join it uses, is a somewhat controversial design decision. The core PostgreSQL developers feel that it's more 
//important to focus on improving the optimizer so it works correctly in all cases instead of just allowing queries 
//to hint at a plan as a workaround for problems.



// There are some add-on tools some find useful for exploring the PostgreSQL planner. pgAdmin includes an explain plan 
// viewer (sample). Another option is Visual Explain, originally a RedHat component that has been kept current and 
// improved by Enterprise DB. It comes bundled with the EnterpriseDB Advanced Server package and can be built to run 
// against other PostgreSQL installations using the source code to their Developer Studio package.
Il y'a quelque outils complémentaires pour explorer le planificateur de PostgreSQL. pgAdmin inclus une visionneuse 
de plan d'exécution. Une autre option est "Visual Explain", à l'origine un composant de RedHat qui est maintenant
maintenu par Enterprise DB. Il est inclus dans l'offre EnterpriseDB Advanced Server et peut être compiler avec une 
installation de PostgreSQL en utilisant le code source du paquet "Developer Studio".


//Credits and Feedback
Remerciements et Remarques

// This document was written by Greg Smith with substantial contributions by Christopher Browne, Lukas Kahwe Smith, 
// and other members of the PostgreSQL Advocacy mailing list. Some of the references linked to by this document 
// point to articles also written by these authors.
Ce document à été écrit par Greg Smith incluant de pertinante contribution de Christopher Browne, Lukas Kahwe Smith,
et beaucoup d'autres membres de la liste de diffusion Advocacy. Quelques unes de ces références citées dans ce document
proviennent d'articles qui ont été écrit par ces mêmes auteur.

// Corrections, suggestions, flames, and similar feedback should be addressed to Greg, an independent consultant 
// whose only affiliation with The PostgreSQL Global Development Group consists of submitting patches to improve 
// the upcoming 8.3 release. He feels that PostgreSQL stands on its own merits and comparisons with MySQL should be 
// as factual as possible, and feedback will be treated accordingly.
Corrections, suggestions, coup de gueule, et autres remarques peuvent être adresser à Greg, un consultant indépendant
dont le seul lien avec l'équipe de développement mondial consiste à soumettre des patchs pour améliorer la future 
version 8.3
